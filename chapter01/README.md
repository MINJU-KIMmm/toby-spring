# 1장, 오브젝트와 의존관계

## Intro

### 스프링의 핵심 철학

자바의 객체지향 프로그래밍 -> 오브젝트에 대한 관심

### 오브젝트

- 오브젝트의 라이프 사이클
    - 오브젝트의 생성, 다른 오브젝트와 관계, 사용, 소멸
    - 오브젝트의 설계, 단위, 과정 등
- 오브젝트에 대한 관심
- 오브젝트의 설계로 발전
- 객체지향설계(OOD, Object Oriented Design)의 기초와 원칙
- 디자인 패턴 : 다양한 목적을 위해 재활용 가능한 설계 방법
- 리팩토링 : 깔끔한 구조가 되도록 지속적인 개선 작업
- 단위테스트 : 오브젝트가 기대한 대로 동작하고 있는지 효과적으로 검증
- 스프링
    - 오브젝트를 어떻게 효과적으로 설계, 구현, 사용, 개선할지에 대한 기준 마련
    - 프레임워크 형태로 제공

## 1.1 초난감 DAO

> DAO란</br>
> DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트


> 자바빈이란</br>
> 원래 비주얼 툴에서 조작가능한 컴포넌트를 말했지만 이제는 비주얼 컴포넌트라기보다는 디폴트 생성자, 프로퍼티의 관례를 따라 만들어진 오브젝트를 가리킨다.
> 간단히 빈이라고 부르기도 한다.
> 디폴트 생성자 : 자바빈은 파라미터가 없는 디폴트 생성자를 갖고 있어야 한다. 툴이나 프레임워크에서 리플렉션을 이용해 오브젝트를 생성
> 프로퍼티 : 자바빈이 노출하는 이름을 가진 속성. setter와 getter를 이용해 수정 또는 조회.


## 1.2 DAO의 분리

`1.2.1`

- 관심사의 분리
    - 관심이 같은 것끼리는 하나의 객체 안으로, 또는 친한 객체로 모이게 하고 관심이 다른 것은 가능한 따로 떨어져 서로 영향을 주지 않도록 분리
    - 변화의 폭을 최소한으로 줄여주기 위한 방법 -> **분리와 확장**을 고려
    - 같은 관심에 효과적으로 집중할 수 있게 만들어 줌

`1.2.2`

- 초난감 DAO코드의 문제점
    - 예외상황 처리 없음
    - **중복 코드 존재**로 인한 스파게티 코드 -> 하나의 관심사가 중복되고 여기저기 흩어져 있어 다른 관심의 대상과 얽혀 변경이 일어날 때 어려움
- 해결법
    - 중복 코드의 메소드 추출(메소드 추출 기법)
        - 중복된 코드를 분리하여 독립적인 메소드로 만들어 줌
        - 관심이 다른 코드가 있는 메소드에는 영향을 주지 않고 관심 내용이 독립적으로 존재하여 수정 간단
    - 변경사항에 대한 검증 : 리팩토링과 테스트
        - 리팩토링 : 기존의 코드를 외부 동작방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업
        - 나쁜 냄새(리팩토링이 필요한 코드의 특징)를 리팩토링을 이용해 제거

`1.2.3`

- **상속**을 통한 확장
    - UserDao에서 메소드의 구현 코드를 제거하고 추상메소드로 만든다.
    - UserDao 클래스를 상속해서 서브클래스를 만들어 관심을 분리하고 기능을 확장한다.
    
    ⇒ 고객에게 소스를 직접 공개하지 않으면서도 변화에 유연하게 대응할 수 있어진다.
    
    ⇒ 상속구조를 통해 성격이 다른 관심사항을 분리한 코드를 만들어내고 서로 영향을 덜 주도록 한다.
    
- **디자인 패턴**
    - 소프트웨어 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할 수 있는 **재사용 가능한 솔루션**
    - 주로 객체지향 설계에 관한 것.
    - 주로 사용되는 확장성 추구 방법(패턴의 설계 구조가 비슷하다)
        - 클래스 사옥
        - 오브젝트 합성
    - 패턴의 핵심이 담긴 목적 또는 의도가 중요하다.
- 템플릿 메소드 패턴
    - **상속**을 통해 슈퍼클래스 기능 확장
    - 슈퍼클래스 : 변하지 않는 기능
        - 추상 메소드 또는 오버라이드 가능한 메소드를 정의해서 템플릿 메소드를 만든다.
        - 훅메소드 : 서브클래스에서 선택적으로 오버라이드할 수 있도록 만든 메소드
    - 서브클래스 : 자주 변경되며 확장할 기능
        - 추상 메소드를 구현하거나 훅메소드를 오버라이드해서 기능 확장
    
    ```java
    public abstract class Super {
    	//기본 알고리즘 코드
    	//기본 알고리즘 골격을 담은 메소드 = 템플릿 메소드
    	//템플릿 메소드는 서브클래스에서 오버라이드하거나 구현할 메소드를 사용한다.
    	hookMethod();
    	abstractMethod();
    	...
    	protected void hookMethod() {} // 선택적으로 오버라이드 가능한 훅메소드
    	public abstract void abstractMethod(); //서브클래스에서 반드시 구현해야하는 추상메소드
    }
    
    //슈퍼클래스의 메소드를 오버라이드하거나 구현해서 기능 확장
    //다양한 확장 클래스를 만들 수 있다.
    public calss Sub1 extends Super {
    	protected void hookMethod(){
    		...
    	}
    	
    	public void abstrcatMethod() {
    		...
    	}
    }
    ```
    
- 팩토리 메소드 패턴
    - 마찬가지로 **상속**을 통해 기능을 확장하게 하는 패턴
    - 슈퍼클래스 : 서브클래스에서 구현할 메소드를 호출해서 필요한 타입의 오브젝트를 가져와 사용
        - 이 메소드는 주로 인터페이스 타입으로 오브젝트를 리턴(서브클래스가 어떤 클래스의 오브젝트를 만들어 리턴할지는 슈퍼클래스는 관심 없음)
    - 서브클래스 : 오브젝트를 생성하는 메소드를 재정의
        - 팩토리 메소드 : 서브 클래스에서 오브젝트 생성 방법과 클래스를 결정할 수 있도록 미리 정의해둔 메소드
        
        ⇒ 이 방식으로 오브젝트생성 방법을 슈퍼클래스의 기본코드에서 독립시킨다.
- 상속 이용의 단점
    - 다중상속을 허용하지 않는 자바의 특성
        - 다른 목적으로 상속을 적용하기 힘들다
    - 밀접한 상속 관계
        - 여전히 상속관계는 다른 관심사에 대해 긴밀한 결합을 허용
        - ex) 슈퍼클래스 내부 변경 → 서브 클래스를 함께 수정하거나 다시 개발
    - 확장된 기능을 다른 DAO 클래스에 적용할 수 없음 → 코드 중복 가능
