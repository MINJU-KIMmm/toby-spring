# 1장, 오브젝트와 의존관계

## Intro

### 스프링의 핵심 철학

자바의 객체지향 프로그래밍 -> 오브젝트에 대한 관심

### 오브젝트

- 오브젝트의 라이프 사이클
    - 오브젝트의 생성, 다른 오브젝트와 관계, 사용, 소멸
    - 오브젝트의 설계, 단위, 과정 등
- 오브젝트에 대한 관심
- 오브젝트의 설계로 발전
- 객체지향설계(OOD, Object Oriented Design)의 기초와 원칙
- 디자인 패턴 : 다양한 목적을 위해 재활용 가능한 설계 방법
- 리팩토링 : 깔끔한 구조가 되도록 지속적인 개선 작업
- 단위테스트 : 오브젝트가 기대한 대로 동작하고 있는지 효과적으로 검증
- 스프링
    - 오브젝트를 어떻게 효과적으로 설계, 구현, 사용, 개선할지에 대한 기준 마련
    - 프레임워크 형태로 제공

## 1.1 초난감 DAO

> DAO란</br>
> DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트


> 자바빈이란</br>
> 원래 비주얼 툴에서 조작가능한 컴포넌트를 말했지만 이제는 비주얼 컴포넌트라기보다는 디폴트 생성자, 프로퍼티의 관례를 따라 만들어진 오브젝트를 가리킨다.
> 간단히 빈이라고 부르기도 한다.
> 디폴트 생성자 : 자바빈은 파라미터가 없는 디폴트 생성자를 갖고 있어야 한다. 툴이나 프레임워크에서 리플렉션을 이용해 오브젝트를 생성
> 프로퍼티 : 자바빈이 노출하는 이름을 가진 속성. setter와 getter를 이용해 수정 또는 조회.


## 1.2 DAO의 분리

`1.2.1`

- 관심사의 분리
    - 관심이 같은 것끼리는 하나의 객체 안으로, 또는 친한 객체로 모이게 하고 관심이 다른 것은 가능한 따로 떨어져 서로 영향을 주지 않도록 분리
    - 변화의 폭을 최소한으로 줄여주기 위한 방법 -> **분리와 확장**을 고려
    - 같은 관심에 효과적으로 집중할 수 있게 만들어 줌

`1.2.2`

- 초난감 DAO코드의 문제점
    - 예외상황 처리 없음
    - **중복 코드 존재**로 인한 스파게티 코드 -> 하나의 관심사가 중복되고 여기저기 흩어져 있어 다른 관심의 대상과 얽혀 변경이 일어날 때 어려움
- 해결법
    - 중복 코드의 메소드 추출(메소드 추출 기법)
        - 중복된 코드를 분리하여 독립적인 메소드로 만들어 줌
        - 관심이 다른 코드가 있는 메소드에는 영향을 주지 않고 관심 내용이 독립적으로 존재하여 수정 간단
    - 변경사항에 대한 검증 : 리팩토링과 테스트
        - 리팩토링 : 기존의 코드를 외부 동작방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업
        - 나쁜 냄새(리팩토링이 필요한 코드의 특징)를 리팩토링을 이용해 제거

`1.2.3`

- **상속**을 통한 확장
    - UserDao에서 메소드의 구현 코드를 제거하고 추상메소드로 만든다.
    - UserDao 클래스를 상속해서 서브클래스를 만들어 관심을 분리하고 기능을 확장한다.
    
    ⇒ 고객에게 소스를 직접 공개하지 않으면서도 변화에 유연하게 대응할 수 있어진다.
    
    ⇒ 상속구조를 통해 성격이 다른 관심사항을 분리한 코드를 만들어내고 서로 영향을 덜 주도록 한다.
    
- **디자인 패턴**
    - 소프트웨어 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할 수 있는 **재사용 가능한 솔루션**
    - 주로 객체지향 설계에 관한 것.
    - 주로 사용되는 확장성 추구 방법(패턴의 설계 구조가 비슷하다)
        - 클래스 사옥
        - 오브젝트 합성
    - 패턴의 핵심이 담긴 목적 또는 의도가 중요하다.
- 템플릿 메소드 패턴
    - **상속**을 통해 슈퍼클래스 기능 확장
    - 슈퍼클래스 : 변하지 않는 기능
        - 추상 메소드 또는 오버라이드 가능한 메소드를 정의해서 템플릿 메소드를 만든다.
        - 훅메소드 : 서브클래스에서 선택적으로 오버라이드할 수 있도록 만든 메소드
    - 서브클래스 : 자주 변경되며 확장할 기능
        - 추상 메소드를 구현하거나 훅메소드를 오버라이드해서 기능 확장
    
    ```java
    public abstract class Super {
    	//기본 알고리즘 코드
    	//기본 알고리즘 골격을 담은 메소드 = 템플릿 메소드
    	//템플릿 메소드는 서브클래스에서 오버라이드하거나 구현할 메소드를 사용한다.
    	hookMethod();
    	abstractMethod();
    	...
    	protected void hookMethod() {} // 선택적으로 오버라이드 가능한 훅메소드
    	public abstract void abstractMethod(); //서브클래스에서 반드시 구현해야하는 추상메소드
    }
    
    //슈퍼클래스의 메소드를 오버라이드하거나 구현해서 기능 확장
    //다양한 확장 클래스를 만들 수 있다.
    public calss Sub1 extends Super {
    	protected void hookMethod(){
    		...
    	}
    	
    	public void abstrcatMethod() {
    		...
    	}
    }
    ```
    
- 팩토리 메소드 패턴
    - 마찬가지로 **상속**을 통해 기능을 확장하게 하는 패턴
    - 슈퍼클래스 : 서브클래스에서 구현할 메소드를 호출해서 필요한 타입의 오브젝트를 가져와 사용
        - 이 메소드는 주로 인터페이스 타입으로 오브젝트를 리턴(서브클래스가 어떤 클래스의 오브젝트를 만들어 리턴할지는 슈퍼클래스는 관심 없음)
    - 서브클래스 : 오브젝트를 생성하는 메소드를 재정의
        - 팩토리 메소드 : 서브 클래스에서 오브젝트 생성 방법과 클래스를 결정할 수 있도록 미리 정의해둔 메소드
        
        ⇒ 이 방식으로 오브젝트생성 방법을 슈퍼클래스의 기본코드에서 독립시킨다.
- 상속 이용의 단점
    - 다중상속을 허용하지 않는 자바의 특성
        - 다른 목적으로 상속을 적용하기 힘들다
    - 밀접한 상속 관계
        - 여전히 상속관계는 다른 관심사에 대해 긴밀한 결합을 허용
        - ex) 슈퍼클래스 내부 변경 → 서브 클래스를 함께 수정하거나 다시 개발
    - 확장된 기능을 다른 DAO 클래스에 적용할 수 없음 → 코드 중복 가능
## 1.3 DAO의 확장

- 변화의 성격이 다르다 = 변화의 이유, 시기, 주기 등이 다르다

### 1.3.1 클래스의 분리

- 성격이 다른 관심사를 독립적인 클래스로 분리하기
    - 자유로운 확장에 반하는 문제
        - 메소드가 많아지면 커넥션을 가져오는 코드를 일일이 변경해주는 작업의 양이 많아진다.
        - DB커넥션을 제공하는 클래스가 어떤 것인지를 UserDao가 구체적으로 알고 있어야 한다.
    - ⇒ 원인 : UserDao가 DB커넥션을 가져오는 클래스(바뀔 수 있는 정보)에 대해 너무 많이 알기 때문
        - UserDao가 DB커넥션을 가져오는 **구체적인 방법에 종속된다.**

### 1.3.2 인터페이스의 도입

- 인터페이스 : 추상화를 위한 도구
    - 두개의 클래스가 서로 긴밀하게 연결되어 있지 않게 분리할 수 있다.
    - 어떤 일을 하겠다는 기능만 정의. 어떻게 하겠다는 구현 방법은 나타나 있지 않다.
        - → 어떻게 구현할지는 인터페이스를 구현한 클래스들이 결정
        - UserDao는 인터페이스를 통해 알 수 있는 기능에만 관심. 어떻게 구현했는지는 관심 X
    - 문제
        - 생성자 코드가 제거되지 않고 남아 있다
            
            ex) `connectionMaker = new DConnectionMaker()`
            

### 1.3.3 관계설정 책임의 분리

- 오브젝트와 오브젝트 사이의 관계를 설정해줘야 함
    - cf) 클래스 사이의 관계 : 코드에 다른 클래스 이름이 나타나 만들어지는 관계
    - 오브젝트 사이의 관계 : 코드는 특정 클래스를 몰라도 인터페이스 사용했다면 그 클래스의 오브젝트를 인터페이스 타입으로 받아서 사용
        - ← **다형성**
        - ⇒ 클라이언트 측에서 파라미터로 전달

### 1.3.4 원칙과 패턴

- **개방 폐쇄 원칙(OCP, Open-Closed Principle)**
    - 클래스나 모듈은 확장에는 열려 있어야 하고(개방), 변경에는 닫혀 있어야 한다(폐쇄)
    - 인터페이스를 통해 제공되는 확장 포인트 : 개방
    - 인터페이스를 이용하는 클래스 : 폐쇄(자신에게 불필요한 변화가 없도록)
    - **높은 응집도와 낮은 결합도**
        - 높은 응집도 : 하나의 모듈, 클래스가 하나의 책임, 관심사에만 집중
        - 낮은 결합도 : 관련 없는 외부 관심과 책임이 얽혀있지 않음
    - **전략 패턴** : 자신의 기능 맥락에서 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리, 이를 구현한 구체적인 알고리즘(독립적인 책임으로 분리 가능한 기능) 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴
- 객체지향 설계 원칙(SOLID)
    - SRP(The Single Responsibility Principle) : 단일 책임 원칙
    - OCP(The Open Closed Principle) : 개방 폐쇄 원칙
    - LSP(The Liskov Substitution Principle) : 리스코프 치환 원칙
    - ISP(The Interface Segregation Principle): 인터페이스 분리 원칙
    - DIP(The Dependency Inversion Principle) : 의존관계 역전 원칙
- 스프링
    - 객체지향적 설계원칙과 디자인패턴에 나타난 장점을 개발자들이 활용할 수 있게 해주는 프레임워크
